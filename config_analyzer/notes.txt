TODO :
Pas sur que edit version soit nécessaire à supprimer peut être
Refonte de software base config en le générant à partir des config client
Est-ce que si on créé un software base config file avec le même nom qu'un qui existe déjà mais qui est rattaché à un logiciel ou une version différente, ca ne pose pas de probleme ?

harmoniser la position des boutons dans partials/add


Dans vos routes d'édition/suppression, gérez le cas 'global' :

Ajouter la possibilité d'ajouter des params à toutes les entités qui ont tel parametre = à ça

Ajouter un login
Ajouter une traduction
S'assurer que /software.name/software.version/SoftwareBaseConfigurationFile.file_name est un identifiant unique
Dans /Evotec.exe/3.0.5.0/params.cfg qu'est ce qu'on fait si des valeurs sont pas dans le parsed file ? On les affiche à la fin ?
On pourrait utiliser les séprateurs <nom> du fichier parsé pour diviser en plusieurs tableaux plus facile à lire
On pourrait ajouter une notion d'ordre d'affichage des lignes pour pouvoir les modifiers (ajax glisser déposer ?)
Ajouter un compteur sur les routes, les vues et les vues pour pouvoir supprimer du code qui ne sert a rien si le compteur reste à zéro pendant l'utilisation de l'application sur un temp long

Modifier robot_client.html pour inclure un bloc qui permet d'ajouter "rapidement un client", pour ce faire il va falloir creer dans templates/add/partials/robot_client.html dans lequel on pourra choisir quels champs afficher (on décide au moment de l'include)
Et donc on viendra finallement modifier templates/add/robot_client.html qui lui affichera le partial avec le base.html

Ne jamais supprimer quelque chose mais plutôt le mettre en in_use = 0
Si in_use = 0 alors on renomme slon slug en d_old_slug pour qu'il gene pas les autres
Si on essaye de créer un objet qui existe déjà avec un in_use = 0 alors on propose de réactiver à la place

Reco de Claude :

Créer des helpers Python pour la logique CRUD et la validation
Généraliser les styles CSS pour une cohérence visuelle
Mettre en place un système de notifications flash standardisé

toujours https
interface d'administration
Autorisation par rôles : Utilisez le décorateur @roles_required de Flask-User pour sécuriser vos routes
Flexibilité des niveaux d'accès : Complétez votre système d'access_level avec des rôles plus granulaires pour des permissions spécifiques
Gestion de session : Assurez-vous d'utiliser correctement Flask-Login pour gérer l'authentification et les sessions utilisateur
Interface utilisateur : Ajoutez des conditions dans vos templates pour afficher différents éléments selon l'authentification et les rôles de l'utilisateur
roles

http://localhost:5000/software_versions/1/view
sur cette page il faut afficher + d'infos dans la liste des fichiers config de base, comme par exemple, nombre de parametres, nombre de parametres avec regle, nombre de clients connu avec cette version, etc

http://localhost:5000/software_base_configuration/Evotec.exe/3.0.5.0/params.cfg
ici on peut reprendre les info affichés par l'edit

Base de données vs Base document vs Base Graph (arrangoDb)

Notes :

On peut dans la db pour les champs dangereux (par exemple les nom de table dans additionalparam utiliser des enums plutôt que laisser le champ libre)
class TableType(enum.Enum):
    CLIENT = "clients"
    ROBOT_CLIENT = "robot_clients"
    ROBOT_MODEL = "robot_models"
    SOFTWARE = "softwares"
    SOFTWARE_VERSION = "software_versions"

idem pour les regles (equals/contains/regex-match/ignore/etc)

Remember :

Pour modif db

plus nécessaire
docker-compose exec config_analyzer flask db init 

a chaques modifs
docker-compose exec config_analyzer flask db migrate -m "Description des changements"
docker-compose exec config_analyzer flask db upgrade

en cas de modif des relations 
docker exec -it config_analyzer_app flask db stamp head


convention de nommage avec Flask :

Structure de dossiers
tree /F /A config_analyzer > arborescence.txt

2. Règles pour les modèles

Fichiers : Nom au singulier, snake_case
Ex: client.py, machine_client.py

Classes : PascalCase au singulier
Ex: class Client, class MachineClient

Tables : __tablename__ en snake_case pluriel
Ex: __tablename__ = 'clients'

3. Règles pour les relations Many-to-Many

Table d'association :
Nom = [model1]_[model2] (ordre alphabétique) pluriel
Ex: robot_software.py pour Robot <> Software

4. Règles pour les Blueprints

Fichiers : Nom au pluriel
Ex: clients.py, machine_clients.py

Nom du blueprint : [ressource]_bp (pluriel)
Ex: clients_bp = Blueprint('clients', __name__)

URL prefix : /api/v1/[ressource]
Ex: app.register_blueprint(clients_bp, url_prefix='/api/v1/clients')

5. Convention pour les noms de variables

Instance unique : Singulier
Ex: client = Client.query.get(1)

Collections : Pluriel
Ex: clients = Client.query.all()

Relations :
One-to-Many: client.machines (pluriel)
Many-to-One: machine.client (singulier)


